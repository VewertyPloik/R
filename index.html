<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Ninja Shadow Duel vs AI - Mobile Friendly</title>
<style>
  html, body {
    margin: 0; 
    background: #121212;
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  #gameCanvas {
    background: linear-gradient(90deg, #222 0%, #000 100%);
    display: block;
    border: 3px solid #444;
    touch-action: none;
    width: 100vw;
    max-width: 640px;
    height: 360px;
  }
  #ui {
    width: 100%;
    max-width: 640px;
    margin: 5px auto;
    text-align: center;
    user-select: none;
  }
  #score {
    font-size: 20px;
    margin-bottom: 5px;
  }
  #restartBtn {
    background: #222;
    border: 2px solid #66ccff;
    color: #66ccff;
    padding: 8px 16px;
    cursor: pointer;
    font-weight: bold;
    border-radius: 6px;
  }
  #restartBtn:hover {
    background: #66ccff;
    color: #222;
  }

  /* Mobile buttons container */
  #touchControls {
    position: fixed;
    bottom: 10px;
    left: 0;
    width: 100vw;
    max-width: 640px;
    height: 140px;
    pointer-events: none;
    user-select: none;
  }

  /* Button base */
  .btn {
    position: absolute;
    background: rgba(102, 204, 255, 0.25);
    border: 2px solid #66ccff;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    pointer-events: auto;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #66ccff;
    font-weight: bold;
    font-size: 24px;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    transition: background-color 0.15s ease;
    touch-action: none;
  }
  .btn:active, .btn.pressed {
    background: rgba(102, 204, 255, 0.6);
  }

  /* Left / Right buttons on bottom-left */
  #btnLeft {
    bottom: 10px;
    left: 10px;
  }
  #btnRight {
    bottom: 10px;
    left: 80px;
  }
  #btnJump {
    bottom: 80px;
    left: 50px;
  }

  /* Action buttons bottom-right */
  #btnDash {
    bottom: 80px;
    right: 130px;
  }
  #btnShuriken {
    bottom: 10px;
    right: 130px;
  }
  #btnMelee {
    bottom: 80px;
    right: 60px;
  }
  #btnInvis {
    bottom: 10px;
    right: 60px;
  }

</style>
</head>
<body>

<canvas id="gameCanvas" width="640" height="360"></canvas>
<div id="ui">
  <div id="score">Score: 0</div>
  <button id="restartBtn" style="display:none;">Restart Duel</button>
</div>

<!-- Touch buttons -->
<div id="touchControls">
  <div id="btnLeft" class="btn">◀</div>
  <div id="btnRight" class="btn">▶</div>
  <div id="btnJump" class="btn">▲</div>
  <div id="btnDash" class="btn">Dash</div>
  <div id="btnShuriken" class="btn">Z</div>
  <div id="btnMelee" class="btn">X</div>
  <div id="btnInvis" class="btn">C</div>
</div>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const width = canvas.width;
  const height = canvas.height;

  const scoreDiv = document.getElementById("score");
  const restartBtn = document.getElementById("restartBtn");

  // Controls state
  const keys = {
    left: false,
    right: false,
    up: false,
    dash: false,
    shuriken: false,
    melee: false,
    invis: false,
  };

  // Keyboard mapping
  window.addEventListener("keydown", e => {
    if (e.repeat) return;
    switch(e.code) {
      case "ArrowLeft": keys.left = true; break;
      case "ArrowRight": keys.right = true; break;
      case "ArrowUp": keys.up = true; break;
      case "Space": keys.dash = true; break;
      case "KeyZ": keys.shuriken = true; break;
      case "KeyX": keys.melee = true; break;
      case "KeyC": keys.invis = true; break;
    }
  });
  window.addEventListener("keyup", e => {
    switch(e.code) {
      case "ArrowLeft": keys.left = false; break;
      case "ArrowRight": keys.right = false; break;
      case "ArrowUp": keys.up = false; break;
      case "Space": keys.dash = false; break;
      case "KeyZ": keys.shuriken = false; break;
      case "KeyX": keys.melee = false; break;
      case "KeyC": keys.invis = false; break;
    }
  });

  // Mobile buttons & handlers
  function bindButton(id, keyName) {
    const btn = document.getElementById(id);
    btn.addEventListener("touchstart", e => {
      e.preventDefault();
      keys[keyName] = true;
      btn.classList.add("pressed");
    }, {passive:false});
    btn.addEventListener("touchend", e => {
      e.preventDefault();
      keys[keyName] = false;
      btn.classList.remove("pressed");
    }, {passive:false});
    btn.addEventListener("touchcancel", e => {
      e.preventDefault();
      keys[keyName] = false;
      btn.classList.remove("pressed");
    }, {passive:false});
  }

  bindButton("btnLeft", "left");
  bindButton("btnRight", "right");
  bindButton("btnJump", "up");
  bindButton("btnDash", "dash");
  bindButton("btnShuriken", "shuriken");
  bindButton("btnMelee", "melee");
  bindButton("btnInvis", "invis");

  // Game constants
  const GRAVITY = 0.8;
  const FLOOR_Y = height - 40;
  const DASH_SPEED = 10;
  const MOVE_SPEED = 3.5;
  const JUMP_SPEED = -12;
  const SHURIKEN_SPEED = 8;
  const INVIS_DURATION = 3000; // 3 seconds
  const INVIS_COOLDOWN = 10000; // 10 seconds cooldown
  const DASH_COOLDOWN = 1000; // 1 sec cooldown
  const MELEE_COOLDOWN = 800; // 0.8 sec cooldown
  const SHURIKEN_COOLDOWN = 1500; // 1.5 sec cooldown

  // Helper functions
  function rectsOverlap(r1, r2) {
    return !(r2.x > r1.x + r1.w ||
             r2.x + r2.w < r1.x ||
             r2.y > r1.y + r1.h ||
             r2.y + r2.h < r1.y);
  }

  // Ninja and Shuriken classes same as before...

  class Ninja {
    constructor(x, y, isAI=false) {
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.w = 32;
      this.h = 48;
      this.onGround = false;
      this.facing = 1;
      this.health = 100;
      this.isAI = isAI;

      this.dashTimer = 0;
      this.dashCooldownTimer = 0;

      this.meleeCooldownTimer = 0;
      this.shurikenCooldownTimer = 0;
      this.invisCooldownTimer = 0;
      this.invisTimer = 0;

      this.shurikens = [];

      this.invisible = false;

      this.score = 0;

      this.actionQueue = [];
      this.aiLastDecision = 0;
    }

    update(deltaTime) {
      if (this.health <= 0) return;

      this.dashCooldownTimer -= deltaTime;
      this.meleeCooldownTimer -= deltaTime;
      this.shurikenCooldownTimer -= deltaTime;
      this.invisCooldownTimer -= deltaTime;
      if (this.invisTimer > 0) {
        this.invisTimer -= deltaTime;
        if (this.invisTimer <= 0) this.invisible = false;
      }

      this.vy += GRAVITY;

      this.x += this.vx;
      this.y += this.vy;

      if (this.y + this.h > FLOOR_Y) {
        this.y = FLOOR_Y - this.h;
        this.vy = 0;
        this.onGround = true;
      } else {
        this.onGround = false;
      }

      if (this.x < 10) this.x = 10;
      if (this.x + this.w > width - 10) this.x = width - 10 - this.w;

      this.shurikens = this.shurikens.filter(s => {
        s.update();
        return !s.toRemove;
      });
    }

    dash(direction) {
      if (this.dashCooldownTimer > 0) return false;
      this.vx = DASH_SPEED * direction;
      this.dashCooldownTimer = DASH_COOLDOWN;
      return true;
    }

    jump() {
      if (this.onGround) {
        this.vy = JUMP_SPEED;
        this.onGround = false;
      }
    }

    meleeAttack(opponent) {
      if (this.meleeCooldownTimer > 0) return false;
      const attackBox = {
        x: this.facing === 1 ? this.x + this.w : this.x - 20,
        y: this.y + 10,
        w: 20,
        h: this.h - 20
      };
      const oppBox = {x: opponent.x, y: opponent.y, w: opponent.w, h: opponent.h};
      if (!opponent.invisible && rectsOverlap(attackBox, oppBox)) {
        opponent.takeDamage(15);
        this.score += 15;
      }
      this.meleeCooldownTimer = MELEE_COOLDOWN;
      return true;
    }

    throwShuriken() {
      if (this.shurikenCooldownTimer > 0) return false;
      const sx = this.facing === 1 ? this.x + this.w : this.x - 10;
      const sy = this.y + this.h / 2;
      const svx = SHURIKEN_SPEED * this.facing;
      this.shurikens.push(new Shuriken(sx, sy, svx));
      this.shurikenCooldownTimer = SHURIKEN_COOLDOWN;
      return true;
    }

    activateInvisibility() {
      if (this.invisCooldownTimer > 0 || this.invisible) return false;
      this.invisible = true;
      this.invisTimer = INVIS_DURATION;
      this.invisCooldownTimer = INVIS_COOLDOWN;
      return true;
    }

    takeDamage(amount) {
      if (this.invisible) return;
      this.health -= amount;
      if (this.health < 0) this.health = 0;
    }

    render(ctx) {
      ctx.save();
      if (this.invisible) {
        ctx.globalAlpha = 0.4 + 0.6 * Math.sin(Date.now() / 150);
      }
      ctx.fillStyle = this.isAI ? "#e74c3c" : "#3498db";
      ctx.fillRect(this.x, this.y, this.w, this.h);
      ctx.fillStyle = "white";
      let eyeX = this.facing === 1 ? this.x + this.w - 10 : this.x + 10;
      let eyeY = this.y + 15;
      ctx.fillRect(eyeX, eyeY, 8, 8);
      ctx.fillStyle = "#ddd";
      let swordX = this.facing === 1 ? this.x + this.w : this.x - 6;
      ctx.fillRect(swordX, this.y + 10, 6, 30);
      ctx.restore();

      this.shurikens.forEach(s => s.render(ctx));
    }
  }

  class Shuriken {
    constructor(x, y, vx) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.w = 12;
      this.h = 12;
      this.toRemove = false;
    }
    update() {
      this.x += this.vx;
      if (this.x < -20 || this.x > width + 20) this.toRemove = true;
    }
    render(ctx) {
      ctx.save();
      ctx.translate(this.x + this.w/2, this.y + this.h/2);
      ctx.rotate(Date.now() / 200);
      ctx.fillStyle = "#f1c40f";
      ctx.beginPath();
      for(let i=0;i<4;i++){
        ctx.lineTo(0, 6);
        ctx.rotate(Math.PI/2);
        ctx.lineTo(0, -6);
        ctx.rotate(Math.PI/2);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  class NinjaAI extends Ninja {
    constructor(x, y, target) {
      super(x, y, true);
      this.target = target;
      this.decisionInterval = 800;
      this.lastDecisionTime = 0;
    }
    update(deltaTime, currentTime) {
      if (this.health <= 0) return;

      super.update(deltaTime);

      if (currentTime - this.lastDecisionTime > this.decisionInterval) {
        this.makeDecision();
        this.lastDecisionTime = currentTime;
      }

      let distX = this.target.x - this.x;
      this.facing = distX > 0 ? 1 : -1;

      if (Math.abs(distX) > 120) {
        this.vx = MOVE_SPEED * this.facing;
      } else if (Math.abs(distX) < 80) {
        this.vx = MOVE_SPEED * -this.facing;
        if (Math.random() < 0.2) {
          this.dash(-this.facing);
        }
      } else {
        this.vx = 0;
      }

      if (this.onGround && Math.random() < 0.02) {
        this.jump();
      }

      this.shurikens.forEach(s => {
        const hitBox = {x: this.target.x, y: this.target.y, w: this.target.w, h: this.target.h};
        const shurikenBox = {x: s.x, y: s.y, w: s.w, h: s.h};
        if (!this.target.invisible && rectsOverlap(shurikenBox, hitBox)) {
          this.target.takeDamage(10);
          this.score += 10;
          s.toRemove = true;
        }
      });
    }
    makeDecision() {
      if (this.health < 40 && this.invisCooldownTimer <= 0 && !this.invisible) {
        this.activateInvisibility();
        return;
      }
      let distX = this.target.x - this.x;
      if (Math.abs(distX) < 50) {
        if (Math.random() < 0.7) {
          this.meleeAttack(this.target);
        } else if (Math.random() < 0.5) {
          this.throwShuriken();
        }
      } else {
        if (this.shurikenCooldownTimer <= 0) {
          this.throwShuriken();
        }
      }
    }
  }

  // Init players
  const player = new Ninja(100, FLOOR_Y - 48, false);
  const ai = new NinjaAI(width - 150, FLOOR_Y - 48, player);

  let lastTime = performance.now();
  let gameOver = false;

  function resetGame() {
    player.x = 100;
    player.y = FLOOR_Y - player.h;
    player.health = 100;
    player.vx = 0;
    player.vy = 0;
    player.invisible = false;
    player.invisTimer = 0;
    player.invisCooldownTimer = 0;
    player.dashCooldownTimer = 0;
    player.meleeCooldownTimer = 0;
    player.shurikenCooldownTimer = 0;
    player.shurikens = [];
    player.score = 0;

    ai.x = width - 150;
    ai.y = FLOOR_Y - ai.h;
    ai.health = 100;
    ai.vx = 0;
    ai.vy = 0;
    ai.invisible = false;
    ai.invisTimer = 0;
    ai.invisCooldownTimer = 0;
    ai.dashCooldownTimer = 0;
    ai.meleeCooldownTimer = 0;
    ai.shurikenCooldownTimer = 0;
    ai.shurikens = [];
    ai.score = 0;
    ai.lastDecisionTime = 0;

    gameOver = false;
    restartBtn.style.display = "none";
    scoreDiv.textContent = "Score: 0";
  }

  restartBtn.addEventListener("click", () => {
    resetGame();
    requestAnimationFrame(gameLoop);
  });

  function handlePlayerInput(deltaTime) {
    if (player.health <= 0) return;

    if (keys.left) {
      player.vx = -MOVE_SPEED;
      player.facing = -1;
    } else if (keys.right) {
      player.vx = MOVE_SPEED;
      player.facing = 1;
    } else {
      player.vx *= 0.8;
      if (Math.abs(player.vx) < 0.1) player.vx = 0;
    }

    if (keys.up) {
      player.jump();
    }

    if (keys.dash) {
      if (player.dashCooldownTimer <= 0) {
        player.dash(player.facing);
      }
    }

    if (keys.melee) {
      player.meleeAttack(ai);
    }

    if (keys.shuriken) {
      player.throwShuriken();
    }

    if (keys.invis) {
      player.activateInvisibility();
    }
  }

  function update(deltaTime, currentTime) {
    handlePlayerInput(deltaTime);

    player.update(deltaTime);
    ai.update(deltaTime, currentTime);

    // Player shurikens hit AI
    player.shurikens.forEach(s => {
      const aiBox = {x: ai.x, y: ai.y, w: ai.w, h: ai.h};
      const shurikenBox = {x: s.x, y: s.y, w: s.w, h: s.h};
      if (!ai.invisible && rectsOverlap(shurikenBox, aiBox)) {
        ai.takeDamage(10);
        player.score += 10;
        s.toRemove = true;
      }
    });

    scoreDiv.textContent = "Score: " + player.score;
  }

  function render() {
    ctx.clearRect(0, 0, width, height);

    ctx.fillStyle = "#333";
    ctx.fillRect(0, FLOOR_Y, width, height - FLOOR_Y);

    ctx.fillStyle = "#aa2222";
    for (let i = 0; i < 10; i++) {
      ctx.beginPath();
      ctx.moveTo(i * 64, FLOOR_Y);
      ctx.lineTo(i * 64 + 16, FLOOR_Y - 20);
      ctx.lineTo(i * 64 + 32, FLOOR_Y);
      ctx.fill();

      let r = width - i * 64;
      ctx.beginPath();
      ctx.moveTo(r, FLOOR_Y);
      ctx.lineTo(r - 16, FLOOR_Y - 20);
      ctx.lineTo(r - 32, FLOOR_Y);
      ctx.fill();
    }

    function drawHealthBar(x, y, health, color) {
      ctx.fillStyle = "#222";
      ctx.fillRect(x, y, 104, 16);
      ctx.fillStyle = color;
      ctx.fillRect(x + 2, y + 2, health, 12);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(x, y, 104, 16);
    }

    drawHealthBar(20, 20, player.health, "#3498db");
    drawHealthBar(width - 124, 20, ai.health, "#e74c3c");

    player.render(ctx);
    ai.render(ctx);
  }

  function gameLoop(timestamp) {
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    if (gameOver) return;

    update(deltaTime, timestamp);
    render();

    if (player.health <= 0 || ai.health <= 0) {
      gameOver = true;
      restartBtn.style.display = "inline-block";
      if (player.health <= 0 && ai.health <= 0) {
        scoreDiv.textContent = "Draw!";
      } else if (player.health <= 0) {
        scoreDiv.textContent = "You Lost! Score: " + player.score;
      } else {
        scoreDiv.textContent = "You Won! Score: " + player.score;
      }
      return;
    }

    requestAnimationFrame(gameLoop);
  }

  resetGame();
  requestAnimationFrame(gameLoop);

})();
</script>

</body>
</html>
