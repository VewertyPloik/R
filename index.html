<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Basketball Shot Game</title>
<style>
  body, html {
    margin:0; padding:0; overflow:hidden;
    background: #1a1a1a;
    color: white;
    font-family: Arial, sans-serif;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }
  #gameCanvas {
    display: block;
    margin: 0 auto;
    background: #0c1b2a;
    border: 3px solid #555;
    max-width: 100vw;
    max-height: 100vh;
  }
  #ui {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  button {
    font-size: 20px;
    padding: 12px 25px;
    margin: 10px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    background-color: #4caf50;
    color: white;
    min-width: 140px;
  }
  button:hover {
    background-color: #45a049;
  }
  .ballSelector {
    margin-top: 15px;
    font-size: 36px;
    cursor: pointer;
    padding: 8px 12px;
    border-radius: 8px;
    border: 2px solid transparent;
    user-select: none;
    transition: border-color 0.3s ease;
  }
  .ballSelected {
    border-color: gold;
  }
  #message {
    margin-top: 20px;
    font-size: 22px;
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="400" height="600"></canvas>
<div id="ui"></div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let width = canvas.width;
  let height = canvas.height;

  // Responsive canvas
  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    width = rect.width * dpr;
    height = rect.height * dpr;
    canvas.width = width;
    canvas.height = height;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
  }
  function fitCanvas() {
    let w = window.innerWidth;
    let h = window.innerHeight;
    let scaleWidth = w;
    let scaleHeight = (w * 3) / 2;
    if(scaleHeight > h){
      scaleHeight = h;
      scaleWidth = (h * 2) / 3;
    }
    canvas.style.width = scaleWidth + "px";
    canvas.style.height = scaleHeight + "px";
    resizeCanvas();
  }
  window.addEventListener('resize', fitCanvas);
  window.addEventListener('orientationchange', fitCanvas);
  fitCanvas();

  const ui = document.getElementById('ui');

  // Game state
  const gameState = {
    screen: 'home', // 'home', 'playing', 'result'
    selectedBall: 'üèÄ',
    shotPower: 0,
    shotDirection: 1,
    shotSpeed: 0.02,
    shooting: false,
    shotProgress: 0,
    shotMade: false,
    message: '',
  };

  // Draw hoop
  function drawHoop() {
    const hoopX = width / 2;
    const hoopY = height / 4;
    const hoopWidth = 150;
    const hoopHeight = 25;

    // Backboard
    ctx.fillStyle = '#663300';
    ctx.fillRect(hoopX - 10, hoopY - 60, 20, 60);

    // Rim
    ctx.strokeStyle = 'orange';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(hoopX, hoopY, hoopWidth/2, 0, Math.PI, false);
    ctx.stroke();

    // Net cords (simple lines)
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    const cords = 8;
    for(let i = 0; i <= cords; i++) {
      const x = hoopX - hoopWidth/2 + (i * hoopWidth/cords);
      ctx.beginPath();
      ctx.moveTo(x, hoopY);
      ctx.lineTo(x - 5, hoopY + 40);
      ctx.stroke();
    }

    // Net bottom arc
    ctx.beginPath();
    ctx.arc(hoopX, hoopY + 40, hoopWidth/2 + 5, Math.PI, 0, true);
    ctx.stroke();
  }

  // Draw ball emoji
  function drawBall(x, y) {
    ctx.font = '40px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(gameState.selectedBall, x, y);
  }

  // Shot bar constants
  const bar = {
    x: width/2 - 140,
    y: height - 120,
    width: 280,
    height: 30,
  };

  // Draw shot bar with zones
  function drawShotBar(power) {
    // Background bar (red zone - 100%)
    ctx.fillStyle = '#cc0000'; // red
    ctx.fillRect(bar.x, bar.y, bar.width, bar.height);

    // Yellow zone outer (about 60%)
    const yellowMargin = bar.width * 0.2;
    ctx.fillStyle = '#ccaa00'; // yellow
    ctx.fillRect(bar.x + yellowMargin, bar.y, bar.width - 2*yellowMargin, bar.height);

    // Green zone small middle (about 20%)
    const greenMargin = bar.width * 0.4;
    ctx.fillStyle = '#00cc00'; // green
    ctx.fillRect(bar.x + greenMargin, bar.y, bar.width - 2*greenMargin, bar.height);

    // Moving power indicator (white vertical line)
    const pos = bar.x + power * bar.width;
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(pos, bar.y);
    ctx.lineTo(pos, bar.y + bar.height);
    ctx.stroke();
  }

  // Determine shot chance based on power zone
  function getShotChance(power) {
    if(power > 0.4 && power < 0.6) return 0.9; // green zone
    if(power > 0.2 && power <= 0.4 || power >= 0.6 && power < 0.8) return 0.5; // yellow zone
    return 0.1; // red zone
  }

  // Animation variables for shot
  const hoopX = width / 2;
  const hoopY = height / 4;

  // Ball position during shot animation
  let animBall = {x: width / 2, y: height - 80};

  // Animation duration in frames
  const shotFrames = 40;

  // Draw hoop + ball at current animation position
  function drawShotAnimation(frame) {
    ctx.clearRect(0, 0, width, height);
    drawHoop();
    // Animate ball in arc towards hoop rim
    // Simple quadratic Bezier curve
    const startX = width / 2;
    const startY = height - 80;
    const cpX = hoopX;
    const cpY = hoopY + 100; // control point under rim for arc
    const endX = hoopX;
    const endY = hoopY + 10;

    let t = frame / shotFrames;
    // Calculate quadratic Bezier position
    const x = (1-t)*(1-t)*startX + 2*(1-t)*t*cpX + t*t*endX;
    const y = (1-t)*(1-t)*startY + 2*(1-t)*t*cpY + t*t*endY;

    drawBall(x, y);

    // Draw hoop again on top
    drawHoop();

    // Optionally draw net sway or rim glow on made shots - omitted for simplicity
  }

  // Show Home Screen UI
  function renderHomeScreen() {
    gameState.screen = 'home';
    ctx.clearRect(0,0,width,height);
    ui.innerHTML = '';

    const title = document.createElement('h1');
    title.textContent = 'Basketball Shot';
    ui.appendChild(title);

    const playBtn = document.createElement('button');
    playBtn.textContent = 'Play';
    playBtn.onclick = () => {
      startGame();
    };
    ui.appendChild(playBtn);

    const selectorLabel = document.createElement('div');
    selectorLabel.style.marginTop = '15px';
    selectorLabel.style.fontSize = '20px';
    selectorLabel.textContent = 'Select Ball:';
    ui.appendChild(selectorLabel);

    const balls = ['üèÄ', '‚öΩÔ∏è', '‚öæÔ∏è'];
    const selectorDiv = document.createElement('div');
    selectorDiv.style.display = 'flex';
    selectorDiv.style.justifyContent = 'center';
    selectorDiv.style.gap = '20px';
    selectorDiv.style.marginTop = '10px';

    balls.forEach(ball => {
      const ballDiv = document.createElement('div');
      ballDiv.textContent = ball;
      ballDiv.className = 'ballSelector';
      if (gameState.selectedBall === ball) {
        ballDiv.classList.add('ballSelected');
      }
      ballDiv.onclick = () => {
        gameState.selectedBall = ball;
        renderHomeScreen();
      };
      selectorDiv.appendChild(ballDiv);
    });

    ui.appendChild(selectorDiv);
  }

  // Start playing screen
  function startGame() {
    gameState.screen = 'playing';
    gameState.shotPower = 0;
    gameState.shotDirection = 1;
    gameState.shotSpeed = 0.02 + Math.random()*0.01;
    gameState.shooting = false;
    gameState.shotProgress = 0;
    gameState.shotMade = false;
    gameState.message = '';
    ui.innerHTML = '';
    drawPlayScreen();
  }

  // Draw game screen with shot bar
  function drawPlayScreen() {
    ctx.clearRect(0,0,width,height);
    drawHoop();
    drawBall(width/2, height - 80);

    drawShotBar(gameState.shotPower);

    if (gameState.message) {
      ctx.fillStyle = 'white';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(gameState.message, width / 2, height / 2);
    }
  }

  // Animate shot sequence
  let shotAnimationFrame = 0;
  function animateShot() {
    if (shotAnimationFrame <= shotFrames) {
      drawShotAnimation(shotAnimationFrame);
      shotAnimationFrame++;
      requestAnimationFrame(animateShot);
    } else {
      // Show message and return to home after short delay
      if (gameState.shotMade) {
        gameState.message = 'Swish! üèÄ';
      } else {
        gameState.message = 'Airball...';
      }
      drawPlayScreen();
      setTimeout(() => {
        renderHomeScreen();
      }, 1500);
    }
  }

  // Game loop for shot power bar
  function gameLoop() {
    if (gameState.screen === 'playing' && !gameState.shooting) {
      gameState.shotPower += gameState.shotSpeed;
      if (gameState.shotPower >= 1 || gameState.shotPower <= 0) {
        gameState.shotSpeed *= -1;
        gameState.shotPower = Math.min(1, Math.max(0, gameState.shotPower));
      }
      drawPlayScreen();
    }
    requestAnimationFrame(gameLoop);
  }

  // Shoot function
  function shoot() {
    if (gameState.shooting) return;
    gameState.shooting = true;

    const chance = getShotChance(gameState.shotPower);
    gameState.shotMade = Math.random() < chance;

    shotAnimationFrame = 0;
    animateShot();
  }

  // Shot chance function (copied from earlier)
  function getShotChance(power) {
    if(power > 0.4 && power < 0.6) return 0.9;
    if((power > 0.2 && power <= 0.4) || (power >= 0.6 && power < 0.8)) return 0.5;
    return 0.1;
  }

  // Input handlers
  function setupInput() {
    // Mobile / desktop tap/click to shoot
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      if (gameState.screen === 'playing' && !gameState.shooting) shoot();
    }, {passive:false});

    canvas.addEventListener('mousedown', e => {
      if (gameState.screen === 'playing' && !gameState.shooting) shoot();
    });
  }

  // Initial start
  renderHomeScreen();
  gameLoop();
  setupInput();

})();
</script>

</body>
</html>
