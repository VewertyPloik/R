<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Ninja Shadow Duel - Levels & Sounds</title>
<style>
  html, body {
    margin: 0; 
    background: #121212;
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #score {
    font-size: 22px;
    margin: 10px auto 5px;
    font-weight: bold;
    user-select: none;
    text-align: center;
    width: 100%;
    max-width: 640px;
  }
  #gameCanvas {
    background: linear-gradient(90deg, #222 0%, #000 100%);
    display: block;
    border: 3px solid #444;
    touch-action: none;
    width: 100vw;
    max-width: 640px;
    height: 360px;
  }
  #ui {
    width: 100%;
    max-width: 640px;
    margin: 5px auto;
    text-align: center;
  }
  #restartBtn {
    background: #222;
    border: 2px solid #66ccff;
    color: #66ccff;
    padding: 8px 16px;
    cursor: pointer;
    font-weight: bold;
    border-radius: 6px;
    margin-top: 8px;
    display: none;
  }
  #restartBtn:hover {
    background: #66ccff;
    color: #222;
  }

  /* Mobile buttons container */
  #touchControls {
    position: fixed;
    bottom: 10px;
    left: 0;
    width: 100vw;
    max-width: 640px;
    height: 140px;
    pointer-events: none;
    user-select: none;
  }
  /* Button base */
  .btn {
    position: absolute;
    background: rgba(102, 204, 255, 0.25);
    border: 2px solid #66ccff;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    pointer-events: auto;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #66ccff;
    font-weight: bold;
    font-size: 24px;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    transition: background-color 0.15s ease;
    touch-action: none;
  }
  .btn:active, .btn.pressed {
    background: rgba(102, 204, 255, 0.6);
  }
  /* Left / Right buttons on bottom-left */
  #btnLeft {
    bottom: 10px;
    left: 10px;
  }
  #btnRight {
    bottom: 10px;
    left: 80px;
  }
  #btnJump {
    bottom: 80px;
    left: 50px;
  }
  /* Action buttons bottom-right */
  #btnDash {
    bottom: 80px;
    right: 130px;
  }
  #btnShuriken {
    bottom: 10px;
    right: 130px;
  }
  #btnMelee {
    bottom: 80px;
    right: 60px;
  }
  #btnInvis {
    bottom: 10px;
    right: 60px;
  }

  /* Home Screen */
  #homeScreen, #levelSelect {
    position: fixed;
    top: 0; left: 0; right:0; bottom:0;
    background: #121212dd;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    z-index: 10;
    padding: 20px;
  }
  #homeScreen h1 {
    font-size: 36px;
    margin-bottom: 10px;
  }
  #homeScreen p, #homeScreen ul {
    max-width: 480px;
    font-size: 18px;
    line-height: 1.4;
    margin-bottom: 12px;
  }
  #btnStart, #btnLevelBack {
    cursor: pointer;
    background: #222;
    border: 2px solid #66ccff;
    color: #66ccff;
    padding: 12px 20px;
    font-size: 20px;
    font-weight: bold;
    border-radius: 6px;
    margin-top: 15px;
    user-select: none;
  }
  #btnStart:hover, #btnLevelBack:hover {
    background: #66ccff;
    color: #222;
  }
  #levelSelect {
    flex-wrap: wrap;
    padding: 10px 20px;
    overflow-y: auto;
  }
  #levelSelect h2 {
    width: 100%;
    text-align: center;
    margin-bottom: 15px;
  }
  .levelBtn {
    background: #222;
    border: 2px solid #3498db;
    color: #3498db;
    padding: 10px 14px;
    margin: 5px;
    width: 60px;
    text-align: center;
    font-weight: bold;
    cursor: pointer;
    border-radius: 5px;
    user-select: none;
  }
  .levelBtn:hover {
    background: #3498db;
    color: #222;
  }

</style>
</head>
<body>

<div id="homeScreen">
  <h1>Ninja Shadow Duel</h1>
  <p>Fight a deadly AI ninja in shadow combat! Use your skills to dash, jump, throw shurikens, and disappear in shadows.</p>
  <h3>Controls</h3>
  <ul>
    <li><b>Left / Right:</b> Arrow keys or Left/Right buttons</li>
    <li><b>Jump:</b> Up arrow or ▲ button</li>
    <li><b>Dash:</b> Spacebar or Dash button</li>
    <li><b>Throw Shuriken:</b> Z key or Z button</li>
    <li><b>Melee Attack:</b> X key or X button</li>
    <li><b>Invisibility:</b> C key or C button</li>
  </ul>
  <button id="btnStart">Start Duel</button>
</div>

<div id="levelSelect" style="display:none;">
  <h2>Select Level</h2>
  <div id="levelsContainer" style="display:flex; flex-wrap: wrap; justify-content: center; max-width: 480px;"></div>
  <button id="btnLevelBack">Back to Home</button>
</div>

<div id="score">Score: 0</div>
<canvas id="gameCanvas" width="640" height="360"></canvas>
<div id="ui">
  <button id="restartBtn">Restart Duel</button>
</div>

<!-- Touch Buttons -->
<div id="touchControls">
  <div id="btnLeft" class="btn">◀</div>
  <div id="btnRight" class="btn">▶</div>
  <div id="btnJump" class="btn">▲</div>
  <div id="btnDash" class="btn">Dash</div>
  <div id="btnShuriken" class="btn">Z</div>
  <div id="btnMelee" class="btn">X</div>
  <div id="btnInvis" class="btn">C</div>
</div>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const width = canvas.width;
  const height = canvas.height;

  const scoreDiv = document.getElementById("score");
  const restartBtn = document.getElementById("restartBtn");
  const homeScreen = document.getElementById("homeScreen");
  const levelSelect = document.getElementById("levelSelect");
  const levelsContainer = document.getElementById("levelsContainer");
  const btnStart = document.getElementById("btnStart");
  const btnLevelBack = document.getElementById("btnLevelBack");

  // Controls state
  const keys = {
    left: false,
    right: false,
    up: false,
    dash: false,
    shuriken: false,
    melee: false,
    invis: false,
  };

  // Game State
  let currentLevel = 1;
  let gameOver = false;
  let lastTime = performance.now();

  // Audio - Simple beep sounds for actions
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function playTone(freq, duration=150, volume=0.2) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.frequency.value = freq;
    osc.type = "square";
    gain.gain.value = volume;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration/1000);
    osc.onended = () => {
      gain.disconnect();
      osc.disconnect();
    };
  }

  // Sound wrappers
  const sounds = {
    jump: () => playTone(440, 120),
    dash: () => playTone(600, 100),
    shuriken: () => playTone(880, 150),
    melee: () => playTone(330, 100),
    invis: () => playTone(550, 300),
    hit: () => playTone(200, 200),
    aiAttack: () => playTone(300, 180),
    win: () => playTone(900, 400),
    lose: () => playTone(150, 400),
  };

  // Keyboard mapping
  window.addEventListener("keydown", e => {
    if (e.repeat) return;
    switch(e.code) {
      case "ArrowLeft": keys.left = true; break;
      case "ArrowRight": keys.right = true; break;
      case "ArrowUp": keys.up = true; break;
      case "Space": keys.dash = true; break;
      case "KeyZ": keys.shuriken = true; break;
      case "KeyX": keys.melee = true; break;
      case "KeyC": keys.invis = true; break;
    }
  });
  window.addEventListener("keyup", e => {
    switch(e.code) {
      case "ArrowLeft": keys.left = false; break;
      case "ArrowRight": keys.right = false; break;
      case "ArrowUp": keys.up = false; break;
      case "Space": keys.dash = false; break;
      case "KeyZ": keys.shuriken = false; break;
      case "KeyX": keys.melee = false; break;
      case "KeyC": keys.invis = false; break;
    }
  });

  // Mobile buttons & handlers
  function bindButton(id, keyName) {
    const btn = document.getElementById(id);
    btn.addEventListener("touchstart", e => {
      e.preventDefault();
      keys[keyName] = true;
      btn.classList.add("pressed");
    }, {passive:false});
    btn.addEventListener("touchend", e => {
      e.preventDefault();
      keys[keyName] = false;
      btn.classList.remove("pressed");
    }, {passive:false});
    btn.addEventListener("touchcancel", e => {
      e.preventDefault();
      keys[keyName] = false;
      btn.classList.remove("pressed");
    }, {passive:false});
  }
  bindButton("btnLeft", "left");
  bindButton("btnRight", "right");
  bindButton("btnJump", "up");
  bindButton("btnDash", "dash");
  bindButton("btnShuriken", "shuriken");
  bindButton("btnMelee", "melee");
  bindButton("btnInvis", "invis");

  // Game constants
  const GRAVITY = 0.8;
  const FLOOR_Y = height - 40;
  const MOVE_SPEED_BASE = 3.5;
  const JUMP_SPEED = -12;
  const SHURIKEN_SPEED_BASE = 8;
  const INVIS_DURATION = 3000; // 3 seconds
  const INVIS_COOLDOWN = 10000; // 10 seconds cooldown
  const DASH_COOLDOWN = 1000; // 1 sec cooldown
  const MELEE_COOLDOWN = 800; // 0.8 sec cooldown
  const SHURIKEN_COOLDOWN = 1500; // 1.5 sec cooldown

  // Helper functions
  function rectsOverlap(r1, r2) {
    return !(r2.x > r1.x + r1.w ||
             r2.x + r2.w < r1.x ||
             r2.y > r1.y + r1.h ||
             r2.y + r2.h < r1.y);
  }

  // Ninja and Shuriken classes
  class Ninja {
    constructor(x, y, isAI=false) {
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.w = 32;
      this.h = 48;
      this.onGround = false;
      this.facing = 1;
      this.health = 100;
      this.isAI = isAI;

      this.dashTimer = 0;
      this.dashCooldownTimer = 0;

      this.meleeCooldownTimer = 0;
      this.shurikenCooldownTimer = 0;
      this.invisCooldownTimer = 0;
      this.invisTimer = 0;

      this.shurikens = [];

      this.invisible = false;

      this.score = 0;
    }

    update(deltaTime) {
      if (this.health <= 0) return;

      this.dashCooldownTimer -= deltaTime;
      this.meleeCooldownTimer -= deltaTime;
      this.shurikenCooldownTimer -= deltaTime;
      this.invisCooldownTimer -= deltaTime;
      if (this.invisTimer > 0) {
        this.invisTimer -= deltaTime;
        if (this.invisTimer <= 0) this.invisible = false;
      }

      this.vy += GRAVITY;

      this.x += this.vx;
      this.y += this.vy;

      if (this.y + this.h > FLOOR_Y) {
        this.y = FLOOR_Y - this.h;
        this.vy = 0;
        this.onGround = true;
      } else {
        this.onGround = false;
      }

      if (this.x < 10) this.x = 10;
      if (this.x + this.w > width - 10) this.x = width - 10 - this.w;

      this.shurikens = this.shurikens.filter(s => {
        s.update();
        return !s.toRemove;
      });
    }

    dash(direction) {
      if (this.dashCooldownTimer > 0) return false;
      this.vx = DASH_COOLDOWN > 0 ? direction * this.vx : 0;
      this.vx = direction * (MOVE_SPEED_BASE * 3);
      this.dashCooldownTimer = DASH_COOLDOWN;
      sounds.dash();
      return true;
    }

    jump() {
      if (this.onGround) {
        this.vy = JUMP_SPEED;
        this.onGround = false;
        sounds.jump();
      }
    }

    meleeAttack(opponent) {
      if (this.meleeCooldownTimer > 0) return false;
      const attackBox = {
        x: this.facing === 1 ? this.x + this.w : this.x - 20,
        y: this.y + 10,
        w: 20,
        h: this.h - 20
      };
      const oppBox = {x: opponent.x, y: opponent.y, w: opponent.w, h: opponent.h};
      if (!opponent.invisible && rectsOverlap(attackBox, oppBox)) {
        opponent.takeDamage(15);
        this.score += 15;
        sounds.melee();
      }
      this.meleeCooldownTimer = MELEE_COOLDOWN;
      return true;
    }

    throwShuriken() {
      if (this.shurikenCooldownTimer > 0) return false;
      const sx = this.facing === 1 ? this.x + this.w : this.x - 10;
      const sy = this.y + this.h / 2;
      const svx = SHURIKEN_SPEED_BASE * this.facing;
      this.shurikens.push(new Shuriken(sx, sy, svx));
      this.shurikenCooldownTimer = SHURIKEN_COOLDOWN;
      sounds.shuriken();
      return true;
    }

    activateInvisibility() {
      if (this.invisCooldownTimer > 0 || this.invisible) return false;
      this.invisible = true;
      this.invisTimer = INVIS_DURATION;
      this.invisCooldownTimer = INVIS_COOLDOWN;
      sounds.invis();
      return true;
    }

    takeDamage(amount) {
      if (this.invisible) return;
      this.health -= amount;
      if (this.health < 0) this.health = 0;
      sounds.hit();
    }

    render(ctx) {
      ctx.save();
      if (this.invisible) {
        ctx.globalAlpha = 0.4 + 0.6 * Math.sin(Date.now() / 150);
      }
      ctx.fillStyle = this.isAI ? "#e74c3c" : "#3498db";
      ctx.fillRect(this.x, this.y, this.w, this.h);
      ctx.fillStyle = "white";
      let eyeX = this.facing === 1 ? this.x + this.w - 10 : this.x + 10;
      let eyeY = this.y + 15;
      ctx.fillRect(eyeX, eyeY, 6, 6);
      ctx.restore();

      this.shurikens.forEach(s => s.render(ctx));
    }
  }

  class Shuriken {
    constructor(x, y, vx) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.w = 14;
      this.h = 14;
      this.toRemove = false;
    }

    update() {
      this.x += this.vx;
      if (this.x < -this.w || this.x > width + this.w) {
        this.toRemove = true;
      }
    }

    render(ctx) {
      ctx.save();
      ctx.fillStyle = "#fafafa";
      ctx.translate(this.x + this.w / 2, this.y + this.h / 2);
      ctx.rotate((Date.now() / 100) % (Math.PI * 2));
      ctx.fillRect(-7, -1, 14, 2);
      ctx.fillRect(-1, -7, 2, 14);
      ctx.restore();
    }
  }

  // AI logic - smarter with levels
  class AI extends Ninja {
    constructor(x, y, level) {
      super(x, y, true);
      this.level = level;
      this.health = 50 + level * 10;
      this.moveSpeed = MOVE_SPEED_BASE + level * 0.15;
      this.attackTimer = 0;
      this.attackFrequency = Math.max(800 - level * 30, 250);
      this.dashChance = Math.min(level * 0.05, 0.3);
      this.invisChance = Math.min(level * 0.03, 0.15);
      this.score = 0;
    }

    update(deltaTime, currentTime, player) {
      if (this.health <= 0) return;
      this.dashCooldownTimer -= deltaTime;
      this.meleeCooldownTimer -= deltaTime;
      this.shurikenCooldownTimer -= deltaTime;
      this.invisCooldownTimer -= deltaTime;
      if (this.invisTimer > 0) {
        this.invisTimer -= deltaTime;
        if (this.invisTimer <= 0) this.invisible = false;
      }

      // Simple AI movement toward player
      if (player.x > this.x + this.w) {
        this.vx = this.moveSpeed;
        this.facing = 1;
      } else if (player.x < this.x) {
        this.vx = -this.moveSpeed;
        this.facing = -1;
      } else {
        this.vx = 0;
      }

      // AI jump randomly sometimes if player is higher
      if (this.onGround && player.y + player.h < this.y + this.h && Math.random() < 0.002 * this.level) {
        this.vy = JUMP_SPEED;
        sounds.jump();
      }

      // AI dash sometimes
      if (this.dashCooldownTimer <= 0 && Math.random() < this.dashChance) {
        this.dash(this.facing);
      }

      // AI melee attack if close
      const attackRange = 40;
      const distX = Math.abs(this.x - player.x);
      if (this.meleeCooldownTimer <= 0 && distX < attackRange && !player.invisible) {
        this.meleeAttack(player);
      }

      // AI throw shuriken sometimes
      if (this.shurikenCooldownTimer <= 0 && Math.random() < 0.02 * this.level) {
        this.throwShuriken();
      }

      // AI activate invisibility sometimes
      if (this.invisCooldownTimer <= 0 && !this.invisible && Math.random() < this.invisChance) {
        this.activateInvisibility();
      }

      // Movement and gravity
      this.vy += GRAVITY;
      this.x += this.vx;
      this.y += this.vy;

      if (this.y + this.h > FLOOR_Y) {
        this.y = FLOOR_Y - this.h;
        this.vy = 0;
        this.onGround = true;
      } else {
        this.onGround = false;
      }

      if (this.x < 10) this.x = 10;
      if (this.x + this.w > width - 10) this.x = width - 10 - this.w;

      this.shurikens = this.shurikens.filter(s => {
        s.update();
        return !s.toRemove;
      });
    }
  }

  // Player object
  let player = null;
  let ai = null;

  // Game methods

  function resetGame(level = 1) {
    gameOver = false;
    player = new Ninja(80, FLOOR_Y - 48);
    ai = new AI(width - 120, FLOOR_Y - 48, level);
    scoreDiv.textContent = "Score: 0";
    restartBtn.style.display = "none";
  }

  function handlePlayerInput(deltaTime) {
    if (player.health <= 0) return;

    if (keys.left) {
      player.vx = -MOVE_SPEED_BASE;
      player.facing = -1;
    } else if (keys.right) {
      player.vx = MOVE_SPEED_BASE;
      player.facing = 1;
    } else {
      player.vx *= 0.7;
      if (Math.abs(player.vx) < 0.1) player.vx = 0;
    }

    if (keys.up) {
      player.jump();
    }

    if (keys.dash) {
      if (player.dashCooldownTimer <= 0) {
        player.dash(player.facing);
      }
    }

    if (keys.melee) {
      player.meleeAttack(ai);
    }

    if (keys.shuriken) {
      player.throwShuriken();
    }

    if (keys.invis) {
      player.activateInvisibility();
    }
  }

  function update(deltaTime, currentTime) {
    handlePlayerInput(deltaTime);

    player.update(deltaTime);
    ai.update(deltaTime, currentTime, player);

    // Player shurikens hit AI
    player.shurikens.forEach(s => {
      const aiBox = {x: ai.x, y: ai.y, w: ai.w, h: ai.h};
      const shurikenBox = {x: s.x, y: s.y, w: s.w, h: s.h};
      if (!ai.invisible && rectsOverlap(shurikenBox, aiBox)) {
        ai.takeDamage(10);
        player.score += 10;
        s.toRemove = true;
      }
    });

    // AI shurikens hit player
    ai.shurikens.forEach(s => {
      const playerBox = {x: player.x, y: player.y, w: player.w, h: player.h};
      const shurikenBox = {x: s.x, y: s.y, w: s.w, h: s.h};
      if (!player.invisible && rectsOverlap(shurikenBox, playerBox)) {
        player.takeDamage(10);
        ai.score += 10;
        s.toRemove = true;
      }
    });

    // Update score display with level
    scoreDiv.textContent = `Level ${currentLevel} — Score: ${player.score}`;
  }

  function drawHealthBar(x, y, health, color) {
    ctx.fillStyle = "#222";
    ctx.fillRect(x, y, 104, 16);
    ctx.fillStyle = color;
    ctx.fillRect(x + 2, y + 2, health, 12);
    ctx.strokeStyle = "#000";
    ctx.strokeRect(x, y, 104, 16);
  }

  function render() {
    ctx.clearRect(0, 0, width, height);

    // Floor
    ctx.fillStyle = "#333";
    ctx.fillRect(0, FLOOR_Y, width, height - FLOOR_Y);

    // Spikes decor
    ctx.fillStyle = "#aa2222";
    for (let i = 0; i < 10; i++) {
      ctx.beginPath();
      ctx.moveTo(i * 64, FLOOR_Y);
      ctx.lineTo(i * 64 + 16, FLOOR_Y - 20);
      ctx.lineTo(i * 64 + 32, FLOOR_Y);
      ctx.fill();

      let r = width - i * 64;
      ctx.beginPath();
      ctx.moveTo(r, FLOOR_Y);
      ctx.lineTo(r - 16, FLOOR_Y - 20);
      ctx.lineTo(r - 32, FLOOR_Y);
      ctx.fill();
    }

    // Health bars
    drawHealthBar(20, 20, player.health, "#3498db");
    drawHealthBar(width - 124, 20, ai.health, "#e74c3c");

    // Ninjas and shurikens
    player.render(ctx);
    ai.render(ctx);
  }

  function nextLevel() {
    if (currentLevel < 25) {
      currentLevel++;
      resetGame(currentLevel);
      requestAnimationFrame(gameLoop);
    } else {
      alert("You completed all 25 levels! Congratulations!");
      currentLevel = 1;
      showHomeScreen();
    }
  }

  function gameLoop(timestamp) {
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    if (gameOver) return;

    update(deltaTime, timestamp);
    render();

    if (player.health <= 0 || ai.health <= 0) {
      gameOver = true;
      restartBtn.style.display = "inline-block";

      if (player.health <= 0 && ai.health <= 0) {
        scoreDiv.textContent = "Draw!";
      } else if (player.health <= 0) {
        scoreDiv.textContent = `You Lost! Score: ${player.score}`;
        sounds.lose();
      } else {
        scoreDiv.textContent = `You Won! Score: ${player.score}`;
        sounds.win();
      }
      return;
    }

    requestAnimationFrame(gameLoop);
  }

  // Button events
  restartBtn.addEventListener("click", () => {
    resetGame(currentLevel);
    requestAnimationFrame(gameLoop);
  });

  btnStart.addEventListener("click", () => {
    hideHomeScreen();
    showLevelSelect();
  });

  btnLevelBack.addEventListener("click", () => {
    hideLevelSelect();
    showHomeScreen();
  });

  // Level buttons generation
  function showLevelSelect() {
    levelSelect.style.display = "flex";
    levelsContainer.innerHTML = "";
    for (let i=1; i<=25; i++) {
      const lvlBtn = document.createElement("div");
      lvlBtn.className = "levelBtn";
      lvlBtn.textContent = i;
      lvlBtn.addEventListener("click", () => {
        currentLevel = i;
        resetGame(currentLevel);
        hideLevelSelect();
        requestAnimationFrame(gameLoop);
      });
      levelsContainer.appendChild(lvlBtn);
    }
  }

  function hideLevelSelect() {
    levelSelect.style.display = "none";
  }
  function showHomeScreen() {
    homeScreen.style.display = "flex";
    scoreDiv.style.display = "none";
    canvas.style.display = "none";
    restartBtn.style.display = "none";
    document.getElementById("touchControls").style.display = "none";
  }
  function hideHomeScreen() {
    homeScreen.style.display = "none";
    scoreDiv.style.display = "block";
    canvas.style.display = "block";
    document.getElementById("touchControls").style.display = "block";
  }

  // Start on home screen
  showHomeScreen();

})();
</script>

</body>
</html>
